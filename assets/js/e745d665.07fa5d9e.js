"use strict";(self.webpackChunkmgod=self.webpackChunkmgod||[]).push([[346],{1668:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=t(5893),o=t(1151);const i={title:"Union Types"},a=void 0,r={id:"union_types",title:"Union Types",description:"Sometimes its possible that the API needs to be flexible and support a range of types. An example for this might be a tagging functionality on resources such as user, movies, etc. The CRUD layer for tags entity needs to support operations on multiple types of tags like NumberTag, DateTag, etc. through same functions.",source:"@site/../docs/union_types.md",sourceDirName:".",slug:"/union_types",permalink:"/mgod/docs/union_types",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Union Types"},sidebar:"docsSidebar",previous:{title:"Meta Fields",permalink:"/mgod/docs/meta_fields"}},d={},c=[{value:"Usage",id:"usage",level:2},{value:"Configure schema options for the union type entities",id:"configure-schema-options-for-the-union-type-entities",level:3},{value:"Create ODM for entities",id:"create-odm-for-entities",level:3},{value:"Inserting Documents",id:"inserting-documents",level:3},{value:"Find docs by querying on model properties using the global ODM",id:"find-docs-by-querying-on-model-properties-using-the-global-odm",level:3}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Sometimes its possible that the API needs to be flexible and support a range of types. An example for this might be a tagging functionality on resources such as user, movies, etc. The CRUD layer for tags entity needs to support operations on multiple types of tags like ",(0,s.jsx)(n.code,{children:"NumberTag"}),", ",(0,s.jsx)(n.code,{children:"DateTag"}),", etc. through same functions."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["In Go, to create union types, we need to create a base type and then use it as a struct embedding in children types. For instance, here we are creating two children tag types - ",(0,s.jsx)(n.code,{children:"NumberTag"})," and ",(0,s.jsx)(n.code,{children:"DateTag"})," with ",(0,s.jsx)(n.code,{children:"BaseTag"})," as the base type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type TagTypeEnum string\n\nconst (\n\tTagTypeEnumNumber TagTypeEnum = "number"\n\tTagTypeEnumDate   TagTypeEnum = "date"\n)\n\ntype BaseTag struct {\n\tID   string `bson:"_id" mgoType:"id"`\n\tName string\n\tType TagTypeEnum\n}\n\nfunc (BaseTag) IsTag() {}\n\ntype NumberTag struct {\n\tBaseTag `bson:",inline"`\n\tNumber  int\n}\n\ntype DateTag struct {\n\tBaseTag `bson:",inline"`\n\tDate    string `mgoType:"date"`\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Though we know the type of the doc while insertion, it might not be possible to know the doc type beforehand while querying a collection that stores multiple types of docs like in the case of union types. So, we need a global type that can receive the doc for any of the union types."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type GlobalTag struct {\n\tBaseTag `bson:",inline"`\n\tNumber  *int    `bson:",omitempty"`\n\tDate    *string `bson:",omitempty" mgoType:"date"`\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Only common fields are kept as compulsory whereas other fields are marked optional."})}),"\n",(0,s.jsx)(n.h3,{id:"configure-schema-options-for-the-union-type-entities",children:"Configure schema options for the union type entities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'discriminator := "type"\nschemaOpts := schemaopt.SchemaOptions{\n\tCollection:       "unionTest",\n\tTimestamps:       true,\n\tIsUnionType:      true,\n\tDiscriminatorKey: &discriminator,\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We have used the ",(0,s.jsx)(n.code,{children:"type"})," field as the discriminator in this case, as it a unique key to identify underlying union types."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["In case if we do not provide ",(0,s.jsx)(n.code,{children:"type"})," as the discriminator key, ",(0,s.jsx)(n.code,{children:"__t"})," will be added to the MongoDB doc with its value as the name of its underlying struct type."]})}),"\n",(0,s.jsx)(n.h3,{id:"create-odm-for-entities",children:"Create ODM for entities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"globalTagModel, _ := mgod.NewEntityMongoModel(GlobalTag{}, schemaOpts)\nnumberTagModel, _ := mgod.NewEntityMongoModel(NumberTag{}, schemaOpts)\ndateTagModel, _ := mgod.NewEntityMongoModel(DateTag{}, schemaOpts)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"inserting-documents",children:"Inserting Documents"}),"\n",(0,s.jsx)(n.p,{children:"To insert documents, we have two options:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Use ODM specific to the entity we are inserting in case we have liberty to create separate functions to handle different entities."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'numberTag := NumberTag{\n\t\tBaseTag: BaseTag{\n\t\t\tID:   primitive.NewObjectID().Hex(),\n\t\t\tName: "numberTag",\n\t\t\tType: TagTypeEnumNumber,\n\t\t},\n\t\tNumber: 1,\n\t}\n\ninsertedNumberTag, _ := numberTagModel.InsertOne(context.TODO(), numberTag)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n\t"_id" : ObjectId("65718f9c55e90b39cf538b42"),\n\t"name" : "numberTag",\n\t"type" : "number",\n\t"number" : 1,\n\t"createdAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"updatedAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"__v" : 0\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Use global ODM to insert the doc that is created using the entity ODM. This is helpful in case where we want a common function handle the inserting of entities."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'date, _ := dateformatter.New(time.Now().UTC()).GetISOString()\ndateTag := DateTag{\n\t\tBaseTag: BaseTag{\n\t\t\tID:   primitive.NewObjectID().Hex(),\n\t\t\tName: "dateTag",\n\t\t\tType: TagTypeEnumDate,\n\t\t},\n\t\tDate: date,\n\t}\n\ndateTagDoc, _ := dateTagModel.GetDocToInsert(context.TODO(), numberTag)\n\ninsertedDateTag, _ := globalTagModel.InsertOne(context.TODO(), dateTagDoc)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n\t"_id" : ObjectId("65718f9c55e90b39cf538b43"),\n\t"name" : "dateTag",\n\t"type" : "date",\n\t"date" : ISODate("2023-12-07T09:25:48.252Z"),\n\t"createdAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"updatedAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"__v" : 0\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"find-docs-by-querying-on-model-properties-using-the-global-odm",children:"Find docs by querying on model properties using the global ODM"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'numberTag, _ := globalTagModel.FindOne(context.TODO(), bson.M{"name": "numberTag"})\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'GlobalTag{\n\tBaseTag{\n\t\tID: "65718f9c55e90b39cf538b42",\n\t\tName: "numberTag",\n\t\tType: "number",\n\t},\n\tNumber: 0x1400030c380, // pointer to value of 1\n\tDate: <nil>,\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the above step, before returning the results, all docs received from the MongoDB are validated and processed against their respective typed models based on the discriminator key (here the ",(0,s.jsx)(n.code,{children:"type"})," field). So, in the above step, the number tag document is processed against the schema for NumberTag type before getting converted to the GlobalTag type."]})]})}function g(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var s=t(7294);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);